<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>HW2_Prob2</title>
<meta name="generator" content="MATLAB 24.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2025-10-31">
<meta name="DC.source" content="HW2_Prob2.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<pre class="codeinput">t0 = [0;0;0]; <span class="comment">% setting initial transformation</span>
R0 = [1,0,0;0,1,0;0,0,1]; <span class="comment">% setting initial rotation</span>
X = load(<span class="string">'pclX.txt'</span>);
Y = load(<span class="string">"pclY.txt"</span>);
n_x = size(X,1); <span class="comment">% calculating length of X points</span>
n_y = size(Y,1); <span class="comment">% calculating length of Y points</span>
d_max = 0.25; <span class="comment">% setting maximum distance threshold</span>

num_iter = 30;

<span class="comment">% assigning initial transformation matrices</span>
t=t0;
R=R0;


<span class="keyword">for</span> i = 1:1:num_iter <span class="comment">%setting num_iter here</span>
    disp(i)
C = []; <span class="comment">% creating blank correspondence matrix</span>

    <span class="keyword">for</span> i = 1:1:n_x <span class="comment">% looping through every X point in list</span>
        Xi = X(i,:)'; <span class="comment">% extracting points from X Matrix and making it a column vector</span>
        Xi_trans = R*Xi + t; <span class="comment">% transforming point X to its image under T</span>

        <span class="comment">% Reset min_dist for each new point in X + create default condition</span>
        min_dist = inf;
        best_j = -1; <span class="comment">% index of Y that best matches X_i</span>

        <span class="keyword">for</span> j = 1:1:n_y <span class="comment">%  looping through Y</span>
            Yj = Y(j,:)'; <span class="comment">% extracting points from Y matrix and making it a column vector</span>
            distance = norm(Yj - Xi_trans); <span class="comment">% Euclidean distance between Y_j and transformed X_i</span>

            <span class="keyword">if</span> distance &lt; min_dist
                min_dist = distance; <span class="comment">% updating default condition to find the point Y that best corresponds to X_i</span>
                best_j = j; <span class="comment">% updating default condition index to find the Y that best corresponds to X_i</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% Checking if min point &lt; d_max</span>
        <span class="keyword">if</span> min_dist &lt; d_max <span class="comment">% parent ICP condition</span>
            C = [C; i, best_j]; <span class="comment">% Add correspondence as new row where the elements are the indices of the parent X and Y matrices that correspond</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Horns Method</span>

    K = size(C, 1) ;     <span class="comment">% finding the dimension of the correspondence matix for calcilating weighted means</span>

    X_corr = X(C(:,1), :);     <span class="comment">% extracting correlated X and Y points per C matrix</span>
    Y_corr = Y(C(:,2), :);

    <span class="comment">% Centroids:</span>
    x_bar = mean(X_corr, 1)';  <span class="comment">% finding centroid of X dataset as a column vector</span>
    y_bar = mean(Y_corr, 1)';      <span class="comment">% finding centroid of Y dataset as a column vector</span>

    <span class="comment">%Calculate deviations of each point from the centroid of its pointcloud:</span>

    X_prime = (X_corr - x_bar')';      <span class="comment">%re-transposing X_bar/Y_Bar to find the deviation from the points before transposing into column vector</span>
    Y_prime = (Y_corr - y_bar')';

    <span class="comment">%cross covariance matrix</span>
    W = (Y_prime * X_prime') / K ;

    <span class="comment">%symmetric value decomposition</span>

    [U,S,V] = svd(W);

    <span class="comment">%Constructing optimal rotation.</span>
    diag_matrix = eye(3);
    diag_matrix(3, 3) = det(U * V');

    <span class="comment">%finding rotation matrix</span>
    R_hat = U * diag_matrix * V';
    <span class="comment">%finding translation component</span>
    t_hat = y_bar - R_hat*x_bar;

    <span class="comment">%updating parent rotation and translation matrices ahead of next</span>
    <span class="comment">%iteration</span>

    R=R_hat;
    t=t_hat;


<span class="keyword">end</span>

<span class="comment">%calculating RMSE in 2 steps.</span>

<span class="comment">%STEP 1 - SSE of Corresponded points</span>
SSE = 0;
<span class="keyword">for</span> k = 1:1:K <span class="comment">%looping over length of C</span>

    i = C(k, 1);  <span class="comment">% indices of X</span>
    j = C(k, 2);  <span class="comment">% indices of Y</span>

    x_trans = R * X(i,:)' + t; <span class="comment">%transformed X Coorindates with final R and t</span>
    error_vec = Y(j,:)' - x_trans; <span class="comment">% calculating error between the transformed X and Y</span>
    SSE = SSE + norm(error_vec)^2;
<span class="keyword">end</span>

RMSE = sqrt(SSE / K);
disp(RMSE)
</pre>
<pre class="codeoutput">     1

     2

     3

     4

     5

     6

     7

     8

     9

    10

    11

    12

    13

    14

    15

    16

    17

    18

    19

    20

    21

    22

    23

    24

    25

    26

    27

    28

    29

    30

    0.0090

</pre>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2024b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
t0 = [0;0;0]; % setting initial transformation
R0 = [1,0,0;0,1,0;0,0,1]; % setting initial rotation
X = load('pclX.txt');
Y = load("pclY.txt");
n_x = size(X,1); % calculating length of X points
n_y = size(Y,1); % calculating length of Y points
d_max = 0.25; % setting maximum distance threshold

num_iter = 30;

% assigning initial transformation matrices
t=t0;
R=R0;


for i = 1:1:num_iter %setting num_iter here
    disp(i)
C = []; % creating blank correspondence matrix

    for i = 1:1:n_x % looping through every X point in list
        Xi = X(i,:)'; % extracting points from X Matrix and making it a column vector
        Xi_trans = R*Xi + t; % transforming point X to its image under T
        
        % Reset min_dist for each new point in X + create default condition
        min_dist = inf;
        best_j = -1; % index of Y that best matches X_i
        
        for j = 1:1:n_y %  looping through Y
            Yj = Y(j,:)'; % extracting points from Y matrix and making it a column vector
            distance = norm(Yj - Xi_trans); % Euclidean distance between Y_j and transformed X_i
            
            if distance < min_dist
                min_dist = distance; % updating default condition to find the point Y that best corresponds to X_i
                best_j = j; % updating default condition index to find the Y that best corresponds to X_i
            end
        end
        
        % Checking if min point < d_max
        if min_dist < d_max % parent ICP condition
            C = [C; i, best_j]; % Add correspondence as new row where the elements are the indices of the parent X and Y matrices that correspond
        end
    end
    
    % Horns Method

    K = size(C, 1) ;     % finding the dimension of the correspondence matix for calcilating weighted means            
    
    X_corr = X(C(:,1), :);     % extracting correlated X and Y points per C matrix    
    Y_corr = Y(C(:,2), :);           
    
    % Centroids:
    x_bar = mean(X_corr, 1)';  % finding centroid of X dataset as a column vector    
    y_bar = mean(Y_corr, 1)';      % finding centroid of Y dataset as a column vector  
    
    %Calculate deviations of each point from the centroid of its pointcloud:
  
    X_prime = (X_corr - x_bar')';      %re-transposing X_bar/Y_Bar to find the deviation from the points before transposing into column vector
    Y_prime = (Y_corr - y_bar')';     
    
    %cross covariance matrix
    W = (Y_prime * X_prime') / K ;

    %symmetric value decomposition 

    [U,S,V] = svd(W); 

    %Constructing optimal rotation. 
    diag_matrix = eye(3);
    diag_matrix(3, 3) = det(U * V');
    
    %finding rotation matrix
    R_hat = U * diag_matrix * V';
    %finding translation component
    t_hat = y_bar - R_hat*x_bar;

    %updating parent rotation and translation matrices ahead of next
    %iteration
    
    R=R_hat;
    t=t_hat;
    

end

%calculating RMSE in 2 steps. 

%STEP 1 - SSE of Corresponded points
SSE = 0;
for k = 1:1:K %looping over length of C

    i = C(k, 1);  % indices of X
    j = C(k, 2);  % indices of Y
    
    x_trans = R * X(i,:)' + t; %transformed X Coorindates with final R and t
    error_vec = Y(j,:)' - x_trans; % calculating error between the transformed X and Y 
    SSE = SSE + norm(error_vec)^2;
end

RMSE = sqrt(SSE / K);
disp(RMSE)
##### SOURCE END #####
-->
</body>
</html>
